% AutoBOD_data_process.m
%
% Created 19 Aug 2015 by JRC under MATLAB R2015a
% Owner/author: James Collins, MIT-WHOI Joint Program, Woods Hole
% Oceanographic Institution, james.r.collins@aya.yale.edu
%
% Purpose: Read in, parse, and process dissolved oxygen data from the
% AutoBOD, a carousel developed in the Van Mooy Lab at WHOI to incubate,
% rotate, and make semi-continuous measurements of dissolved oxygen in
% multiple BOD bottles containing water samples
%
% Dependencies/required files:
%
% 1. An AutoBOD log and metadata file (.xlsx format with timestamps as ISO
% 8601) containing bottle sequence information, locations of individual
% data files, and other required inputs
%
% Caveats:
%
% 1. Assumes data files (as generated by "capture text to file" function of
% your favorite terminal program) have the following consistent fixed-field
% format:
%
%   00033 000351 24.10 999.99 4 0 00033 001 0 08/13/15 18:07:17
%
%   Fields are (in order):
%       
%   1.  Amplitude (signal amplitude in uV)
%   2.  Phase (signal phase shift)
%   3.  Temperature (deg C)
%   4.  Oxygen concentration (mg/L?)
%   5.  "Error" (a "0" indicates that the unit is in range; '4' or
%       'amplitude too low' is a common error when light source does not
%       see a dot)
%   6.  "Bottle lock" (a "1" indicates AutoBOD is locked on a bottle and
%       not transiting)
%   7.  Amplitude again (this is a diagnostic field that; it is a
%       recalculated subroutine value used to to detect the edge of the
%       dot & should match the first field exactly)
%   8.  Bottle counter (not fully developed, as of 8/24/15; really at
%       this point just counts up to 255 and then starts over)
%   9.  Home detect (a "1" in this field indicates the carousel is
%       passing through the home sensor under the platter; this is how
%       we can keep track of the bottles for now)
%   10. Date (from computer clock)
%   11. Time (from computer clock)
%
% 2. Assumes user started AutoBOD with carousel at proper "home" position
% and that the first slug of "good" data appearing in the data file is for
% the bottle given in the log as bottle #1 for that deployment; if this is
% not the case, user may want to truncate the data file manually
%
% 3. Execution of script does not depend on the exact incubation start/end
% times given by the user in the deployment log, since the computer clock
% of the machine on which the data was recorded might have been different
% than the local time at the site; instead, the start/end times given in
% the log are used to calculate the length of the period of data from which
% results are calculated (where the first entry in the data file is t = 0)

%% Clean things up and prep workspace

close all;
clear all;
clf;

%% User: specify some necessary file locations and parameters

% Name and location of bottle log & metadata file
AutoBOD_LogFile = '/Users/jrcollins/Dropbox/Cruises & projects/PHORCYS & AutoBOD/Data/AutoBOD_master_metadata.xlsx';

% Specify the deployments in the log file for which we want to read &
% process data; should be one or more of the deployments in the
% Deployment_metadata field "Deployment_ID"; if left unspecified, script
% will run through all deployments in the log file

Desired_Deployments = ['Iselin_PHORCYS_2015_2'];

Max_RECD = 6; % The maximum allowable read error code deviations
              % this is the maximum number of bad reads allowable in a
              % stretch of "good" data (i.e., when locked onto a spot in a
              % particular bottle), or the number of erroneously good reads
              % in a "bad" (i.e., between bottles) stretch of data; necessary
              % because the measurement hardware isn't perfect

%% Read in & process metadata from log file

% Read in metadata
[num_bottle txt_bottle raw_bottle] = xlsread(AutoBOD_LogFile,'Bottle_metadata');
[num_deploy txt_deploy raw_deploy] = xlsread(AutoBOD_LogFile,'Deployment_metadata');

% Flow fields into cell array AutoBOD_deploy_metadata

% Easy fields first
AutoBOD_deploy_metadata.Deployment_ID = cellstr(raw_deploy(7:end,1));
AutoBOD_deploy_metadata.Cruise_ID = cellstr(txt_deploy(7:end,2));
AutoBOD_deploy_metadata.Incu_temp_deg_C = cell2mat(raw_deploy(7:end,5));
AutoBOD_deploy_metadata.Datafile_loc = cellstr(raw_deploy(7:end,6));
AutoBOD_bottle_metadata.Deployment_ID = cellstr(raw_bottle(6:end,1));
AutoBOD_bottle_metadata.Bottle_ID = cell2mat(raw_bottle(6:end,2));
AutoBOD_bottle_metadata.Sample_ID = cellstr(raw_bottle(6:end,3));
AutoBOD_bottle_metadata.CTD_ID = cellstr(txt_bottle(6:end,4));
AutoBOD_bottle_metadata.Sample_replicate = cell2mat(raw_bottle(6:end,5));
AutoBOD_bottle_metadata.Depth_m = cell2mat(raw_bottle(6:end,6));
AutoBOD_bottle_metadata.Salinity = cell2mat(raw_bottle(6:end,7));
AutoBOD_bottle_metadata.Lat = cell2mat(raw_bottle(6:end,8));
AutoBOD_bottle_metadata.Long = cell2mat(raw_bottle(6:end,9));

% Get number of total deployments in log
NumDeploys = length(AutoBOD_deploy_metadata.Deployment_ID);

% Now, the fields requiring a bit more manipulation

% Time zone
AutoBOD_deploy_metadata.Incu_timezone = regexp(raw_deploy(7:end,3),'.{6}$','match');
AutoBOD_deploy_metadata.Incu_timezone = ...
    reshape([AutoBOD_deploy_metadata.Incu_timezone{:}],NumDeploys,1);

% Incubation start/endtimes
AutoBOD_deploy_metadata.Incu_starttime_UTC = datetime(raw_deploy(7:end,3),...
    'InputFormat','uuuu-MM-dd''T''HH:mm:ssXXX','TimeZone','UTC');
AutoBOD_deploy_metadata.Incu_endtime_UTC = datetime(raw_deploy(7:end,4),...
    'InputFormat','uuuu-MM-dd''T''HH:mm:ssXXX','TimeZone','UTC');

% Create some other timestamps in local time (relative to where deployment
% took place)

% Not creating these as a datetime object, since it appears the entire
% object has to have the same time zone associated with it; this not
% acceptable for our purposes since many of the deployments were conducted
% in different time zones

for i=1:length(AutoBOD_deploy_metadata.Deployment_ID)
    AutoBOD_deploy_metadata.Incu_starttime_local{i} = ...
        datestr(datetime(AutoBOD_deploy_metadata.Incu_starttime_UTC(i),'TimeZone',...
        AutoBOD_deploy_metadata.Incu_timezone{i}));
    AutoBOD_deploy_metadata.Incu_endtime_local{i} = ...
        datestr(datetime(AutoBOD_deploy_metadata.Incu_endtime_UTC(i),'TimeZone',...
        AutoBOD_deploy_metadata.Incu_timezone{i}));
end

clear i

% Calculate deployment durations
AutoBOD_deploy_metadata.Deploy_duration_hours = ...
    AutoBOD_deploy_metadata.Incu_endtime_UTC - ...
    AutoBOD_deploy_metadata.Incu_starttime_UTC;

% Finally, create vector of deployments to be analyzed
if (exist('Desired_Deployments') & ~isempty('Desired_Deployments'))
    Deploy_queue = cellstr(Desired_Deployments);
else
    Deploy_queue = unique(AutoBOD_deploy_metadata.Deployment_ID);
end

%% Analysis, for each desired deployment in Deployment_queue

for i=1:length(Deploy_queue)
    
    
    %% Read-in and parsing of data file
    
    % First, open the datafile for this deployment and determine number of
    % header lines, i.e., initial lines of numbers in the data file that aren't
    % "good" AutoBOD data
    
    HeadCount = 0; % Create a variable to keep track of number of header lines
    
    % Get index of this deployment in metadata array
    Ind_ThisDeploy = find(strcmp([...
        AutoBOD_deploy_metadata.Deployment_ID'],Deploy_queue{i}));
    
    % Open the datafile for this deployment
    FileID = fopen(AutoBOD_deploy_metadata.Datafile_loc{Ind_ThisDeploy});

    while (~feof(FileID))
        TLine = fgetl(FileID); % Get one line of data at a time and evaluate
        if ~isempty(regexp(TLine,'\d{5}\s(\d{6}|[-]\d{5})\s\d{2}[.]\d{2}\s\d{3}[.]\d{2}\s\d\s\d\s\d{5}\s\d{3}\s\d\s\d{2}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2}'))
            % We've hit good data matching the desired pattern, so we can stop
            break;
        end
        HeadCount = HeadCount + 1; % Otherwise, increment our counter
    end
    
    fclose(FileID);
    
    % Now that we know number of lines to ignore, can use textscan to read
    % everything in
   
    % Open the datafile for this deployment (again)
    FileID = fopen(AutoBOD_deploy_metadata.Datafile_loc{Ind_ThisDeploy});
    
    % Read in data using textscan; by its nature, will stop at either EOF
    % or when it hits a line of stuff that doesn't match the pattern
    
    AutoBOD_rawdata = textscan(FileID,'%f %f %f %f %d %d %f %f %f %s %s','HeaderLines',HeadCount);

    fclose(FileID);
    
    % Now, deal with each field
        
    % ****** Create timestamps ******
    
    AutoBOD_data.Timestamp_local = datetime(year(datenum(AutoBOD_rawdata{10})),...
        month(datenum(AutoBOD_rawdata{10})),...
        day(datenum(AutoBOD_rawdata{10})),...
        hour(datenum(AutoBOD_rawdata{11})),...
        minute(datenum(AutoBOD_rawdata{11})),...
        second(datenum(AutoBOD_rawdata{11})),'TimeZone',...
        AutoBOD_deploy_metadata.Incu_timezone{Ind_ThisDeploy});

    % ****** Temperature ****** 
    
    AutoBOD_data.Temp_deg_C = AutoBOD_rawdata{3};
    
    % ****** DO ******
    
    % Read in raw, salinity uncorrected concentration in (we assume) mg/L
    % ****** NOTE: Could actually be %sat with the decimal in a weird place
    
    AutoBOD_data.DO_mg_L_uncorr = AutoBOD_rawdata{4};
    
    % Convert to umol/L
    % Note that we will correct for salinity later, once we figure out
    % what data segment came from which bottle
    AutoBOD_data.DO_uM_O2_uncorr = AutoBOD_data.DO_mg_L_uncorr*(1000)*(1/31.998);

    % ****** Error ****** 
    
    AutoBOD_data.Err = AutoBOD_rawdata{5};
  
    % ****** Bottle lock ****** 
    
    AutoBOD_data.Bot_lock = AutoBOD_rawdata{6};    
            
    % ****** Home detect code ****** 
    
    AutoBOD_data.HD = AutoBOD_rawdata{9};
    
    %% Assignment of each line of DO data in this dataset to a particular bottle number
    
    % Cumbersome, but will accomplish by cycling through each line of data
    % to see if it matches the desired pattern
    
    % Note that we assume the first bottle with data was bottle #1
    
    % Since the data output from the instrument isn't perfect, will have to
    % use multiple criteria to try and hone in on the "good" sections of
    % data
    
    % Often, this will result in some conservative "clipping" of a few
    % lines of good data on either end of a segment
    
    % First, initialize vectors to hold to the bottle numbers we're about
    % to assign, and a sequential ID for each segment of good data
    
    AutoBOD_data.Bot_ID = NaN(length(AutoBOD_data.DO_uM_O2_uncorr),1);
    AutoBOD_data.Segment = NaN(length(AutoBOD_data.DO_uM_O2_uncorr),1);

    % Also, create some counters to keep track of what kind of data
    % we're dealing with
    
    Badcount = 0;
    This_bottle = 1;
    This_segment = 1;

    % Now, cycle through the data
    
    for j=1:length(AutoBOD_data.DO_uM_O2_uncorr)
        
        if AutoBOD_data.DO_uM_O2_uncorr(j) > 800
            
            % As a first check, make sure we don't have a biologically
            % implausible value (the instrument spits out 999.999 as a
            % value in the absence of a good reading)
            
            Badcount = Badcount + 1;
            
        else
            
            if (AutoBOD_data.Err(j)==0 && AutoBOD_data.Bot_lock(j)==1)
                
                % We probably have a line of good data, but have to make
                % sure it isn't an isolated, anomalous reading
                % (these exist in some of the data)
                
                if (sum(AutoBOD_data.Err(j-Max_RECD:j+Max_RECD))<=Max_RECD && ...
                        sum(AutoBOD_data.Bot_lock(j-Max_RECD:j+Max_RECD))>=Max_RECD*1.5)
                    
                    % This line is almost certainly one good line of data within a
                    % series of lines of good data; the cutoffs above
                    % were tuned based on the quantity of "sporadic" bad readings
                    % observed in a number of datasets, but you can still
                    % change them if you want
                
                    AutoBOD_data.Bot_ID(j) = This_bottle;
                    AutoBOD_data.Segment(j) = This_segment;
                    Badcount = 0;
                    
                else
                    
                    Badcount = Badcount + 1;
                    
                end
                    
            else % It's not an "error-free" line of data, so we have to do some investigating
                
                if (j<=Max_RECD || sum(AutoBOD_data.Err(j-Max_RECD:j))==0)
                    
                    % We can be certain we haven't had an error code in the past few
                    % reads
                     
                    if (AutoBOD_data.Err(j)==0 && AutoBOD_data.Bot_lock(j)==0 && ...
                            Badcount<=Max_RECD && j>=3)
                        
                        % We'll give this read the benefit of the doubt, but note it as a
                        % potentially bad line (so long as we've had a recent good
                        % read)
                        
                        AutoBOD_data.Bot_ID(j) = This_bottle;
                        Badcount = Badcount + 1;
                        
                    elseif (AutoBOD_data.Err(j)==0 && AutoBOD_data.Bot_lock(j)==0 && ...
                            Badcount>Max_RECD)
                        
                        % We're likely into bad data
                        
                        Badcount = Badcount + 1;
                        
                    elseif AutoBOD_data.Err(j)==4
                        
                        % We definitely have bad data
                        
                        Badcount = Badcount + 1;
                        
                    end
                    
                else
                    
                    Badcount = Badcount + 1;
                    
                end
                
            end
                        
        end
        
        % Before moving onto the next line of data, we have to determine whether
        % we're still on the same bottle number
        
        if (Badcount==Max_RECD+1 && j>Max_RECD+1)
            
            % Safe to conclude we're at the end of the data for this
            % particular bottle, let's get ready for the next one
            
            % Increment bottle ID
            
            if This_bottle<=11
                
                This_bottle = This_bottle+1;
                
            elseif This_bottle==12
                
                This_bottle = 1;
                
            end
            
            % Increment segment ID
            
            This_segment = This_segment+1;
             
        end
        
    end
    
    %%

    % Now, correct for the salinity noted in the deployment log for this
    % deployment, per:
    %
    % Garcia HE, Gordon LI (1992), Oxygen solubility in seawater: Better
    % fitting equations, Limnol. Oceanogr. 37:1307-1312
    %
    % ***** Critical: Assumes a salinity setting of "0" was used when data
    % were collected; no need to correct for pressure since we're
    % conducting these incubations in lab
    
    % Define coefficients
    B_0 = -6.24097E-03;
    B_1 = -6.93498E-03;
    B_2 = -6.90358E-03;
    B_3 = -4.29155E-03;
    C_0 = -3.11680E-07;
        
    % Calculate a scaled temperature for each reading
    AutoBOD_data.Scaled_temp = log((298.15-AutoBOD_data.Temp_deg_C)./(273.15+AutoBOD_data.Temp_deg_C));
        
    % Calculate a salinity compensation factor
    AutoBOD_data.Sal_comp_factor = exp(Salinity*(...
        B_0+...
        B_1*AutoBOD_data.Scaled_temp+...
        B_2.*(AutoBOD_data.Scaled_temp.^2)+...
        B_3.*(AutoBOD_data.Scaled_temp.^3))+...
        C_0*(Salinity^2));
    
    % Now, can calculate a salinity-corrected DO concentration in umol/L
    
    AutoBOD_data.DO_uM_O2 = AutoBOD_data.DO_uM_O2_uncorr.*AutoBOD_data.Sal_comp_factor;




%%